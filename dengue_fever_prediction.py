# -*- coding: utf-8 -*-
"""Dengue Fever Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10MjCKhOgS6vZIgpwT4n7mwNYSnJQ_COf

# **Linear Regression Model for Dengue Prediction Using Scikit-Learn and Pandas**

**Inport Library** - Panda, scikit-learn
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
import pandas as pd
import matplotlib.pyplot as plt

"""**Load data**"""

df = pd.read_excel('/content/final.xlsx')

"""**Displaying the available data before removing NaN values**"""

print("Available data before removing NaN values:")
print(df)

"""**Check for NaN values in the DataFrame**"""

print("\nChecking for NaN values in the DataFrame:")
print(df.isna().sum())

"""Removing NaN values"""

df.dropna(inplace=True)
df.to_excel('cleaned_data.xlsx', index=False)

"""Rechecking Nan Values"""

print("\nChecking for NaN values after drop nan values:")
print(df.isna().sum())

"""Define the months and corresponding rain column"""

months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec']
rain_columns = ['Rainjan', 'Rainfeb ', 'Rainmar', 'Rainapr', 'Rainmay', 'Rainjune', 'Rainjuly', 'Rainaug', 'Rainsep', 'Rainoct', 'Rainnov', 'Raindec']

"""District name to code mapping"""

district_mapping = {
    'Colombo': 1, 'Gampaha': 2, 'Kalutara': 3, 'Kandy': 4, 'Matale': 5, 'Nuwara Eliya': 6,
    'Galle': 7, 'Hambantota': 8, 'Matara': 9, 'Jaffna': 10, 'Kilinochchi': 11, 'Mannar': 12,
    'Vavuniya': 13, 'Mulativu': 14, 'Batticaloa': 15, 'Ampara': 16, 'Trincomalee': 17,
    'Kalmunai': 18, 'Kurunegala': 19, 'Puttalam': 20, 'Anuradhapura': 21, 'Polonnaruwa': 22,
    'Badulla': 23, 'Moneragala': 24, 'Ratnapura': 25, 'Kegalle': 26
}

results = {}
 # Store Values

"""Loop through each month to train and evaluate models"""

for month, rain_col in zip(months, rain_columns):
    print(f"\nTraining model for {month}...")

    # Select features and target variable for the current month
    X = df[['District code', 'Year', rain_col]]
    y = df[month]

    # Split data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Initialize and train the model
    model = LinearRegression()
    model.fit(X_train, y_train)

    # Make predictions on the testing set
    y_pred = model.predict(X_test)

    # Evaluate the model
    mse = mean_squared_error(y_test, y_pred)
    print(f"Mean Squared Error for {month}: {mse}")

    # Store the results
    results[month] = {
        'model': model,
        'mse': mse,
        'X_test': X_test,
        'y_test': y_test,
        'y_pred': y_pred
    }


# Decision Tree Model
dt_model = DecisionTreeRegressor()
dt_model.fit(X_train, y_train)
dt_predictions = dt_model.predict(X_test)
dt_mse = mean_squared_error(y_test, dt_predictions)

for month, rain_col in zip(months, rain_columns):
    print(f"\nTraining models for {month}...")

    # Select features and target variable for the current month
    X = df[['District code', 'Year', rain_col]]
    y = df[month]

    # Split data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Initialize and train the Linear Regression model
    model = LinearRegression()
    model.fit(X_train, y_train)

    # Make predictions on the testing set
    y_pred = model.predict(X_test)

    # Evaluate the Linear Regression model
    mse = mean_squared_error(y_test, y_pred)
    print(f"Linear Regression Mean Squared Error for {month}: {mse}")

    # Initialize and train the Decision Tree model
    dt_model = DecisionTreeRegressor()
    dt_model.fit(X_train, y_train)
    dt_predictions = dt_model.predict(X_test)
    dt_mse = mean_squared_error(y_test, dt_predictions)
    print(f"Decision Tree Mean Squared Error for {month}: {dt_mse}")

    # Store the results
    results[month] = {
        'linear_regression': {
            'model': model,
            'mse': mse,
            'X_test': X_test,
            'y_test': y_test,
            'y_pred': y_pred
        },
        'decision_tree': {
            'model': dt_model,
            'mse': dt_mse,
            'X_test': X_test,
            'y_test': y_test,
            'y_pred': dt_predictions
        }
    }

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.metrics import mean_squared_error

# Assuming df is your DataFrame with the necessary data
# Example DataFrame creation for demonstration purposes
# Replace this with your actual DataFrame loading
data = {
    'District code': np.random.randint(1, 100, 120),
    'Year': np.random.randint(2000, 2020, 120),
    'Rainfall_Jan': np.random.rand(120) * 100,
    'Rainfall_Feb': np.random.rand(120) * 100,
    'Rainfall_Mar': np.random.rand(120) * 100,
    'Rainfall_Apr': np.random.rand(120) * 100,
    'Rainfall_May': np.random.rand(120) * 100,
    'Rainfall_Jun': np.random.rand(120) * 100,
    'Rainfall_Jul': np.random.rand(120) * 100,
    'Rainfall_Aug': np.random.rand(120) * 100,
    'Rainfall_Sep': np.random.rand(120) * 100,
    'Rainfall_Oct': np.random.rand(120) * 100,
    'Rainfall_Nov': np.random.rand(120) * 100,
    'Rainfall_Dec': np.random.rand(120) * 100,
    'Jan': np.random.rand(120) * 100,
    'Feb': np.random.rand(120) * 100,
    'Mar': np.random.rand(120) * 100,
    'Apr': np.random.rand(120) * 100,
    'May': np.random.rand(120) * 100,
    'Jun': np.random.rand(120) * 100,
    'Jul': np.random.rand(120) * 100,
    'Aug': np.random.rand(120) * 100,
    'Sep': np.random.rand(120) * 100,
    'Oct': np.random.rand(120) * 100,
    'Nov': np.random.rand(120) * 100,
    'Dec': np.random.rand(120) * 100
}
df = pd.DataFrame(data)

months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
rain_columns = ['Rainfall_Jan', 'Rainfall_Feb', 'Rainfall_Mar', 'Rainfall_Apr', 'Rainfall_May',
                'Rainfall_Jun', 'Rainfall_Jul', 'Rainfall_Aug', 'Rainfall_Sep', 'Rainfall_Oct',
                'Rainfall_Nov', 'Rainfall_Dec']
results = {}

for month, rain_col in zip(months, rain_columns):
    print(f"\nTraining models for {month}...")

    # Select features and target variable for the current month
    X = df[['District code', 'Year', rain_col]]
    y = df[month]

    # Split data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Initialize and train the Linear Regression model
    model = LinearRegression()
    model.fit(X_train, y_train)

    # Make predictions on the testing set
    y_pred = model.predict(X_test)

    # Evaluate the Linear Regression model
    mse = mean_squared_error(y_test, y_pred)
    print(f"Linear Regression Mean Squared Error for {month}: {mse}")

    # Initialize and train the Decision Tree model
    dt_model = DecisionTreeRegressor()
    dt_model.fit(X_train, y_train)
    dt_predictions = dt_model.predict(X_test)
    dt_mse = mean_squared_error(y_test, dt_predictions)
    print(f"Decision Tree Mean Squared Error for {month}: {dt_mse}")

    # Store the results
    results[month] = {
        'linear_regression': {
            'model': model,
            'mse': mse,
            'X_test': X_test,
            'y_test': y_test,
            'y_pred': y_pred
        },
        'decision_tree': {
            'model': dt_model,
            'mse': dt_mse,
            'X_test': X_test,
            'y_test': y_test,
            'y_pred': dt_predictions
        }
    }

# Preparing data for combined heatmap for all months
mse_data_combined = {
    'Month': [],
    'Linear Regression MSE': [],
    'Decision Tree MSE': []
}

for month, result in results.items():
    mse_data_combined['Month'].append(month)
    mse_data_combined['Linear Regression MSE'].append(int(result['linear_regression']['mse']))
    mse_data_combined['Decision Tree MSE'].append(int(result['decision_tree']['mse']))

df_mse_combined = pd.DataFrame(mse_data_combined)
df_mse_combined.set_index('Month', inplace=True)

# Creating combined heatmap
plt.figure(figsize=(12, 6))
sns.heatmap(df_mse_combined, annot=True, fmt="d", cmap="coolwarm", linewidths=.5)

plt.title('Heatmap of Mean Squared Error for Linear Regression and Decision Tree Models')
plt.xlabel('Model')
plt.ylabel('Month')
plt.show()

# Function to get district code from district name
def get_district_code(district_name):
    return district_mapping.get(district_name, None)

# Function to make a prediction for a specific month
def predict_rainfall(district_name, year, rain_value, month):
    month = month.capitalize()  # Ensure month name is in the correct format
    if month not in results:
        print(f"Invalid month: {month}")
        return None

    rain_col = f'Rain{month.lower()[:3]}'  # Construct the rain column name
    if month == 'Feb':  # Special case for 'Rainfeb '
        rain_col = 'Rainfeb '

    # Get the district code from the district name
    district_code = get_district_code(district_name)
    if district_code is None:
        print(f"Invalid district name: {district_name}")
        return None

    # Create new data point for the prediction
    new_data = pd.DataFrame({
        'District code': [district_code],
        'Year': [year],
        rain_col: [rain_value]
    })

    # Get the model for the specific month
    model = results[month]['model']
    prediction = model.predict(new_data)
    return prediction[0]

"""User input for prediction"""

# User input for prediction
district_name = input("Enter the district name [Colombo, Gampaha, Kalutara, Kandy, Matale etc...]: ")
year = int(input("Enter the year: "))  # e.g., 2021
new_rain_value = int(input("Enter the rain value: "))  # e.g., 400 (now accepts integer input)
month = input("Enter the month (e.g., Jan, Feb, Mar, etc.): ")  # e.g., 'Jan'

predicted_value = predict_rainfall(district_name, year, new_rain_value, month)
if predicted_value is not None:
    # Convert the predicted value to an integer
    predicted_value = int(predicted_value)
    print(f"\nPredicted value for {month} in {district_name} for the year {year} with rain value {new_rain_value} mm: {predicted_value}")